<document "Tcl Coding Standard">

<hrule>

<contents>

<hrule>

<preface changelog "Change Log">

<changelog>
<change 8/20/2014 Update whd>
Updated for Mars 3.0.x.
</change>

<change 11/18/10 Update whd>
Removed NaturalDocs commenting conventions.
</change>

<change 11/10/09 New whd>
Updated from the JNEM Tcl coding standard.  Updates include:<p>

<ul>
<li> NaturalDocs commenting conventions
</ul>
</change>

</changelog>

<hrule>

<section intro "Introduction">

This page contains the Tcl/Tk coding standards for the Mars
Simulation Infrastructure Library and its client projects.  They apply
to all new work done in Tcl/Tk for Mars, with the following provisos:<p>

<ul>
  <li> Where conformance to some other standard is clearly
       appropriate. For example, when using a framework library like
       RTI it is appropriate to modify these standards so as to be
       consistent with the practices of the framework.<p>

  <li> Where, in the judgement of the programmer, not following the
       standard in a particular case results in manifestly clearer
       code. This is not a license to flout the standard; it is
       intended to cover special circumstances, and must be defensible
       during code reviews.<p>
</ul>

<hrule>

<section intro.base "Base Standard">

The Mars Tcl/Tk Coding Standard is based on the
<i><link http://www.tcl.tk/doc/styleGuide.pdf "Tcl Style Guide"></i>.
This document is the recognized standard for Tcl code within the
Tcl/Tk community at large.  It was originally developed at Sun
Microsystems and is now maintained by the Tcl Core Team. It is,
however, somewhat dated.  Consequently, the standards described here
derive from the <i>Tcl Style Guide</i> but do not depend directly on it.<p>

Many of the module skeletons in <xref file> involve Snit type and
widget definitions; see also the
<link http://tcllib.sourceforge.net/doc/snitfaq.html "Snit FAQ">
for best practices for Snit types.<p>

<section intro.tbd "Standards Yet To Be Written">

<ul>
  <li> Standards for indentation and formatting of SQLite queries.
</ul>

<section form "Code Layout">

This section deals with the general appearance of code at the lines of
code level.

<section form.linelength "Line Length">

In general, lines of code should not exceed 80 characters; where
possible, lines should be broken after about 72 characters.<p>

<section form.linelength.longstrings "Long Text Strings">

An exception can be made for long literal
text strings which define a <b>single</b> line of text.  For example, prefer
code like this<p>

<pre>
    error "This is a very long text string which is a single line of text...."
</pre>

to this<p>

<pre>
    set msg "This is a very long text string "
    append msg "which is a single line of text...."
    error $msg
</pre>

Before letting the string extend past 80 columns, however, first try
to put it on its own line, outdenting if necessary:<p>

<pre>
    error \
"This is a very long text string which is a single line of text...."
</pre>

Long text strings which contain multiple lines of text should be
spread across multiple lines, possibly using
<xref marsutil(n) outdent> or <xref template(n) tsubst> to remove
or preserve indentation.  For example, the following code defines a long
message, indented with the code; the <xref marsutil(n) outdent> command
removes the unwanted whitespace at the beginning of each line:<p>

<pre>
puts [outdent {
    Usage: myscript files....

    myscript(1) randomizes the content of the files listed on
    its command line at the byte level, saving the randomized
    content back to the original file with no backup.  The
    system clock time is used as the random seed; hence, given
    precise knowledge of the system clock time at the start of
    processing and a detailed knowledge of the algorithm, it
    might be possible to reconstruct the original content.
}]
</pre>

<section form.indentation "Indentation">

<ul>
  <li> Tab characters shall <b>not</b> to be used for indentation.<p>

  <li> Text at file scope should be flush with the left margin:<p>

<pre>
proc myproc {} {
    ...
}
</pre>

  <li> Text within curly braces should be indented four spaces
       relative to the line on which the open brace appears:<p>

<pre>
proc myproc {x} {
    if {$x == 1} {
        # Do this
    } else {
        # Do that
    }
}
</pre>

  <li> Continuation lines should be indented four spaces relative to the
       first line in the command.<p>

<pre>
label .mylabel \
    -text       "Hello, World" \
    -foreground black          \
    -background white
</pre>

  <li> Continuations to a bracketed command should usually
       be indented four spaces relative to the bracketed command.<p>

<pre>
set a [list \
           "This item"       \
           "That item"       \
           "The other item"]
</pre>
</ul>

<section form.continuation "Continuation Lines">

In Tcl, commands which continue onto another line need to be escaped
with a backslash ("\") at the end of the previous line.<p>

<ul>
  <li> Avoid using backslashed continuation lines unnecessarily, except for
       certain cases listed below.<p>

  <li> Prefer the natural continuation provided by curly brackets to
       using backslashes.  For example, <b>never</b> use a backslash
       to break a line right before a curly brace.<p>

<pre>
# Don't do this!
if {$x == $y} \
{
    puts $x
}
</pre>

  <li> When a command ends with a homogeneous list of items which is
       too long to fit on one line, consider putting each item on its
       own line.<p>

<pre>
set a [list \
           "This very long item"            \
           "That even longer item"          \
           "The other extremely long item"]
</pre>

       In this case the backslashes on the second and subsequent lines
       should be made to line up, as shown, and should be at least one
       space past the end of the longest item.<p>

  <li> When creating an object (e.g., a Tk widget) with one or more
       creation options, put each option and its value on its own
       line.<p>

<pre>
label .mylabel \
    -text       "Hello, World" \
    -foreground black          \
    -background white
</pre>

       The options, values, and backslashes should line up as shown.<p>

       Format the command this way even if only one or two options are
       being set and the options and values would all fit on the first
       line.<p>

 <pre>
 # Don't do this!
 label .mylabel -text "Hello, World"
 </pre>

  <li> The previous rule generally applies to any command which takes
       a long string of options.<p>
</ul>

<section form.comments "Comments">

Good comments are a must.  Comments are used to structure code modules
so that they are easier to read and specific content easier to find.
At the line-of-code level, Comments should focus on details which are
<b>not</b> obvious from looking at the code.  Comments should protect
the programmers who follow from nasty surprises.<p>

The commenting standards contained in the following subsections
should be observed as far as they go; but do not hesitate to extend
them in exceptional circumstances.<p>

<section form.comments.nd "NaturalDocs">

In of November, 2009, the commenting standard was
changed to allow <link http://www.naturaldocs.org NaturalDocs>
to be used to produce HTML documentation of application and library
internals.  After a year's experience, the development team
determined that NaturalDocs should be abandoned.  The
following features of NaturalDocs-style comments should be removed
from the code in the course of normal maintenance.<p>

<ul>
<li> Style markup should be deleted, e.g., *bold* and _italic_.<p>
     
<li> Header comments no longer need begin with a known keyword,
     e.g., prefer

     <pre>
     # myproc
     # ...

     proc myproc ...
     </pre>

     to
     
     <pre>
     # Proc: myproc
     # ...

     proc myproc ...
     </pre>

<li> Entity links in angle brackets should be removed:<p>

     <pre>
     # Remove the angle brackets here:
     # This is a link to &lt;myproc&gt;.
     </pre>
</ul><p>

<section form.comments.file "File Header Comments">

Every code file should begin with a header comment which looks
generally like this (different kinds of code file may tweak this
comment in different ways, or have additional boilerplate):<p>

<pre>
         1         2         3         4         5         6         7  
123456789012345678901234567890123456789012345678901234567890123456789012
#-----------------------------------------------------------------------
# FILE: tclfile.tcl
#
# A one-line description of the contents of this file.
#
# PACKAGE:
#   One line description of package to which this module belongs.
#
# PROJECT:
#   Name of the project to which this package belongs
#
# AUTHOR:
#   The name(s) of the author(s).
#
#-----------------------------------------------------------------------
</pre>

For example,

<pre>
         1         2         3         4         5         6         7  
123456789012345678901234567890123456789012345678901234567890123456789012
#-----------------------------------------------------------------------
# FILE: executive.tcl
#
# Executive Command Processer
#
# PACKAGE:
#   app_gram(n) -- mars_gram(1) implementation package
#
# PROJECT:
#   Mars Simulation Infrastructure Library
#
# AUTHOR:
#   Will Duquette
#
#-----------------------------------------------------------------------
</pre>

Additional keywords and documentation can be added as needed; content
following each keyword should be indented three spaces from the "#" mark.
The separator lines should be exactly 72 columns wide.  (An editor
which supports templates can be extremely useful here.)<p>

<section form.comments.filesection "File Section Comments">

Code files should be broken into sections using section comments,
which provide a title for the section:<p>

<pre>
         1         2         3         4         5         6         7  
123456789012345678901234567890123456789012345678901234567890123456789012
#-----------------------------------------------------------------------
# Sample Section
</pre>

If the section requires a longer description, it should follow
directly after the section title, separated by a blank comment line.<p>

<pre>
#-----------------------------------------------------------------------
# Sample Section
#
# Here is a longer description of what this section is for,
# what's in it, and so forth.
</pre>

See the descriptions of the various kinds of code file in
<xref file> for commonly used file sections.<p>

<section form.comments.typesection "Type and Widget Sections">

Snit type and widget definitions should also be broken into sections.
In this case, the section comment should be indented, and shortened
so that the row of hyphens still extends to the 72nd column:<p>

<pre>
         1         2         3         4         5         6         7  
123456789012345678901234567890123456789012345678901234567890123456789012
snit::type mytype {
    #-------------------------------------------------------------------
    # Constructor
    ...
}
</pre>

The following sections are commonly used, though rarely all in the
same type or widget definition.<p>

<pre>
snit::type mytype {
    #-------------------------------------------------------------------
    # Type Components

    #-------------------------------------------------------------------
    # Type Variables

    #-------------------------------------------------------------------
    # Type Constructor

    #-------------------------------------------------------------------
    # Public Type Methods

    #-------------------------------------------------------------------
    # Private Type Methods

    #-------------------------------------------------------------------
    # Options

    #-------------------------------------------------------------------
    # Instance Variables

    #-------------------------------------------------------------------
    # Constructor

    #-------------------------------------------------------------------
    # Public Methods

    #-------------------------------------------------------------------
    # Private Methods

    #-------------------------------------------------------------------
    # Utility Methods and Procs
}
</pre><p>

Section headers used for collections of methods and type methods are
fairly fluid; in particular, the groupings implied by the section
titles above should not be considered part of the standard.  If a
public method is implemented in part by one or two private methods
which exist only for that purpose, they should generally follow
directly after the public method.<p>

In short, think of the code file as a document that's telling a story, and
use the grouping that best communicates the story.<p>

<section form.comments.endline "End-line Comments">

In general, full-line comments are preferred to end-line comments.
It is allowable, though, to use end-line comments to document a
sequence of items such as variable declarations:<p>

<pre>
variable thisVariable    5    ;# This short description
variable thatVariable    6    ;# That short description
variable anotherVariable 7    ;# Another short description              
</pre>

If the items can't be cleanly documented as shown--e.g., if one
variable name or value is much longer than the
others--then full-line comments should be used instead.<p>

When end-line commands are used, they should always be written
as shown, with the semicolon immediately preceding the pound sign,
"<b>;#</b>".

<section form.comments.events "Notifier Event Comments">

If a module sends <xref notifier(n)> events, they should be
documented in a section comment near the top of the module.<p>

<section form.comments.components "Component Comments">

Type and instance components should be documented using end-line
comments, unless there is something particularly odd about them; use a
normal comment in the latter case.<p>

<pre>
snit:type {
    ...

    #-------------------------------------------------------------------
    # Type Components

    typecomponent tc1     ;# The kind of component or the role it plays
    typecomponent tc2     ;# The kind of component or the role it plays
    ...

    #-------------------------------------------------------------------
    # Components

    component c1          ;# The kind of component or the role it plays
    component c2          ;# The kind of component or the role it plays
    ...
}
</pre>

<section form.comments.option "Option Comments">

Options defined in a Snit type or widget definition should be placed
in an Options section, and preceded by a comment like this:<p>

<pre>
snit:type {
    #-------------------------------------------------------------------
    # Options
    ...
    # -myoption
    #
    # Description of my option

    option -myoptions \
        -default "My Value" ...
}
</pre>

The description need not include the default value (if any) since it's
right there.<p>

If the option references a <code>-configuremethod</code> or
<code>-cgetmethod</code>, the method may be defined following the
option.  If multiple options reference the same method, it should be
defined at the end of the Options section.<p>

<section form.comments.variable "Variable Comments">

As a general rule, scalar type and instance variables should be
documented with end-line comments unless there is more to be said
than will fit.  Thus, prefer this:<p>

<pre>
    #-------------------------------------------------------------------
    # Type Variables

    typevariable tv1     ;# Something about the variable
    typevariable tv2     ;# Something about the variable
    ...

    #-------------------------------------------------------------------
    # Instance Variables

    variable v1          ;# Something about the variable
    variable v2          ;# Something about the variable
</pre>

Particularly significant type and instance variables should be preceded by a
header comment, like this:<p>

<pre>
snit:type {
    # myvar
    #
    # Description of myvar

    typevariable myvar {...}

    # instvar
    #
    # Description of instvar

    variable instvar {...}
}
</pre>

Array variables with a variety of distinct keys should always be
documented using a header comment; the comment should
list the distinct keys or kinds of key, and the kind of values that
go with them.<p>

<pre>
    # info array
    #
    # An array of information about the state of the simulation.  The
    # keys are as follows.
    #
    #   dbloaded - 1 if a gramdb(5) is loaded, and 0 otherwise
    #   dbfile   - Name of the loaded gramdb(5) file, or ""
    #              if none.
    
    typevariable info -array {
        dbloaded   0
        dbfile     ""
    }
</pre>


<section form.comments.procheader "Procedure Header Comments">

Every procedure definition should begin with a comment that describes
the procedure's calling sequence, arguments, options, purpose, and return
value, along with anything else the developer should know about the
procedure.  The following template should be used:<p>

<pre>
# procname arg1 arg2
#
# arg1 - description of arg1
# arg2 - description of arg2
#
# Description of the proc, including the return value.
# The first sentence should be a good summary of the purpose of the
# proc.
</pre>

The argument names and descriptions should be separated by a hyphen,
as shown.  When there are multiple arguments, the hyphens should be
vertically aligned, one space to the left of the descriptions.<p>

For example,

<pre>
# double x
#
# x - A numeric value
#
# Multiplies x by 2 and returns the result.

proc double {x} {
    ...
}
</pre>

The calling sequence should indicate optional arguments using question
marks, as is done in the standard Tcl man pages.<p>

<pre>
# multiply x ?factor?
#
# x       - A numeric value
# factor  - A numeric value; defaults to 2
#
# Multiplies x by the factor and returns the result.

proc multiply {x {factor 2}} {
    ...
}
</pre>

Repeating arguments should be indicated using an ellipsis ("...").  If
the command takes options, the options and their meanings should be
listed after the normal arguments.<p>

<pre>
# modify x ?options...?
#
# x - A numeric value
#
# Options:
#   -multiplyby factor  - Multiply x by the factor
#   -add value          - Add the value to x.
#
# Modifies x as indicated by the options, which are processed in the
# order of appearances.  Returns the modified value.

proc modify {x args} {
    ...
}
</pre>

<section form.comments.constructor "Constructor Header Comments">

Constructor header comments are just like procedure headers
except that, falling as they do within a type or widget definition,
they are indented four spaces.

<pre>
snit::type mytype {
    ...
    # constructor a b
    #
    # a - A parameter
    # b - Another parameter
    #
    # Creates an instance of mytype given inputs a and b.

    constructor {a b} {
        ...
    }
}
</pre>

If the constructor simply handles the type or widget's options,
there's no need to call attention to the <i>args</i> parameter.<p>

If need be, the destructor can be documented in the same way:<p>

<pre>
    # destructor
    #
    # Cleans up such-and-such.

    destructor {
        ...
    }
</pre>

<section form.comments.methodheader "Method Header Comments">

Method and typemethod header comments are just like procedure headers
except that, falling as they do within a type or widget definition,
they are indented four spaces.  The type or instance command is
omitted from the calling sequence.

<pre>
snit::type mytype {
    ...
    # register tag
    #
    # tag - An identifier string.
    #
    # Registers tag for use with all instances of this type.

    typemethod register {tag} {
        ...
    }

    ...
    
    # modify x
    #
    # x - A numeric value
    #
    # Modifies x as specified by the object's options, and returns the
    # modified value.

    method modify {x} {
        ...
    }
}
</pre>

<section form.comments.body "Procedure/Method Body Comments">

Procedure, method, and typemethod bodies should be broken into logical
paragraphs using FIRST/NEXT comments.  Each such comment should
introduce and describe the block of code that follows.<p>

<pre>
proc UpdateDatabase {args} {
    # FIRST, Validate the arguments.
    ...

    # NEXT, Update the affected database tables
    ...

    # NEXT, Call the -notifycmd callback to notify any interested
    # parties.
    ...
}
</pre>

<ul>
  <li> The block following a FIRST/NEXT comment may be as little as
       one line of code, but will usually be larger.<p>

  <li> Small procedures consisting of only a few lines of code can
       dispense with FIRST/NEXT comments.<p>

  <li> Large loop bodies and then/else clauses should also be broken
       into paragraphs using FIRST/NEXT comments.<p>
</ul>

FIRST/NEXT comments help the body of code to tell its story.<p>

<section code "Code Semantics">

<xref form> dealt with coding standards at the level of appearance;
this section deals with code at the level of meaning.<p>

<section code.naming "Naming Conventions">

This section describes the naming conventions to use in writing
Tcl code.<p>

<section code.naming.camelcase "Prefer Camel Case">

Multi-word names should generally use "Camel Case", e.g.,
"myVariable" rather than "my_variable".  However, there are
exceptions, as called out in the following sections.  In
particular, short multi-word names may use all lowercase with no
separators, provided that the name reads clearly.<p>

<section code.naming.public "Public Names">

A name is public if it is intended for use outside the module or type
definition within which it is defined.<p>

<section code.naming.public.command "Public Command Names">

<ul>
  <li> Public command names should always begin with a lowercase
       letter, e.g., <xref marsutil(n) assert>.<p>

  <li> Where possible without sacrificing clarity, public command names
       should be short, and all lowercase with no separators, e.g.,
       <xref marsutil(n) lmaxlen>, which is short for "list maximum
       length".  This is an extreme case, but it succeeds because the
       name is consistent with those of the standard list manipulation
       commands.<p>

  <li> When defining a family of commands with related names, e.g.,
       "matnew", "matadd", "matmul", consider defining an ensemble
       command instead, e.g., "mat new", "mat add", "mat mul".<p>

  <li> If a code file defines a single ensemble command, the command
       name should match the file name.  (See
       <xref file.mod.ensemble>.)<p>
</ul>

<section code.naming.public.methods "Public Methods and Typemethods">

As with public commands, public method names begin with a lowercase
letter.  Because method and typemethod names are always subcommands of
an ensemble command, they are already read as the second word of a
multiword name.  Consequently they are almost always short, consisting
of one or two words, all lowercase with no separators.<p>

When defining a family of methods with related names, consider using
hierarchical method names instead, i.e., unite them in a
sub-ensemble.  An example is the Tk text widget's "tag *" command and
its subcommands.<p>

<section code.naming.public.variables "Public Variables">

Public variables (those documented for use outside the module in which
they are defined) should have names beginning with a lowercase
letter, e.g., "::mymodule::myVariable".<p>

When referenced from another module, public variables should
always be fully qualified, e.g.,<p>

<pre>
if {$::mymodule::my == 2} {
    ...
}
</pre>

However, use of public variables is discouraged; procedural
interfaces are preferred.<p>

<section code.naming.private "Private Names">

A name is private if it is intended for use only inside the module
within which it is defined.<p>

<section code.naming.private.commands "Private Command Names">

A command is private if it is only intended for use inside the module
within which it is defined.<p>

Private command names always begin with an upper-case letter, and are
frequently much longer than public names, e.g.,
"ComputeMeanSumOfSquares".<p>

<section code.naming.private.methods "Private Methods and Typemethods">

Private method and typemethod names are defined just like private
command names: Camel Case with an initial capital letter, and
frequently with multiple words.<p>

<section code.naming.private.variables "Private and Local Variables">

Private variables, including local variables defined in procedure and
method bodies, private package variables, and Snit instance and type
variables, should be defined with Camel Case names beginning with
an initial lowercase letter.<p>

The previous version of this standard called for private variable
names to begin with a capital letter, to distinguish them from public
variable names; but in practice there are extremely few public variable
names.  Consequently, all variables are written with an initial
lowercase letter.<p>

<section code.expressions "Expressions">

<ul>
  <li> When using <b>expr</b> to compute the value of an expression,
       the expression should always be enclosed in curly braces:<p>

<pre>
    set a [expr {$b * $c}]
</pre>

       If the braces are omitted, both the Tcl
       interpreter and the expression parser will interpolate
       variables.  This degrades performance and can also be source of
       subtle bugs.<p>

  <li> The <xref marsutil(n) let> command is more readable than
       the <b>set/expr</b> idiom, especially when doing a
       sequence of computations:<p>

<pre>
    let a {$b * $c}
    let x {$a*$a + 2*$y}
</pre>

  <li> Note that <xref marsutil(n) let> is slightly slower than
  <b>set/expr</b>; prefer <b>set/expr</b> when performance is crucial.<p>

  <li> Format expressions too long to fit on one line like blocks of
       code.  Indentation should indicating grouping.<p>

<pre>
    let dist {
        $diameter *
        asin(sqrt($sinHalfDlat*$sinHalfDlat +
                  cos($lat1)*cos($lat2)*$sinHalfDlon*$sinHalfDlon))
    }
</pre>
       
  <li> The Tcl Style Guide suggests that expressions should not rely
       on operator precedence, but should always be explicitly
       parenthesized. However, "*" has higher precedence that "+" or
       "-", and they all have higher precedence than "&&" or "||" in
       Tcl, C, C++, and Java, and one should assume that the reader
       knows this.  Thus, it's OK to write:

<pre>
    if {3*$x + 5 == 7 && $y == 9} {
        ...
    }
</pre>

  <li> When an <b>if</b> or <b>while</b> condition consists of a
       series of subexpressions and'd or or'd together, it is usually best
       to put each subexpression on a separate line.<p>

<pre>
    if {3*$x + 5 == 7 &&
        2*$z     == 9 &&
        $y       == 9
    } {
        ...
    }
</pre>

       In this case, the "&&" or "||" operators should line up.<p>
</ul>

<section code.return "Functional Return Values">

The Tcl Style Guide says to always use the "return" statement
rather than relying Tcl to return the value of the last command
executed in the body of a proc.<p>

In procs or methods of one or two lines, however, it is
acceptable to omit the "return" statement, provided that the
command whose value will be returned is the last comand in the
body of the proc or method, and that the documented purpose of the
proc or method is to compute and return a particular value.
Thus, prefer

<pre>
proc double {x} {
    expr {2*$x}
}
</pre>

to<p>

<pre>
proc double {x} {
    return [expr {2*$x}]
}
</pre>
       
This is especially helpful when programming in a more functional
style.<p>

Commands that are called primarily for their side-effects should
always use "return" explicitly if they return a value, regardless of
length of the command.

<section code.typeawareness "Data Type Awareness">

In static languages like C, variables are typed.  In dynamic languages
like Python, variables are untyped but values are typed.  In Tcl,
neither variables nor values are innately typed.  A value can take on
many different types depending on how it is used.  This is possible
because, in Tcl, "everything is a string."<p>

In practice, however, the programmer often knows whether a variable is
supposed to contain an integer, or a floating point number, or a list, or
a string.  The programmer should try to always be aware of the
notional type of each variable and use the appropriate operations for
that type.  Failure to do so can lead to "shimmering", in which Tcl
is constantly having to convert the value's internal representation
from one type to another.  A bad case of shimmering can lead to
serious performance problems.<p>

Therefore,<p>

<ul>
  <li> Use "eq" and "ne" to compare strings for equality rather than
       "==" and "!=".<p>

  <li> Use <b>llength</b> to test for list-emptiness.  This is right:<p>

<pre>
if {[llength $mylist] == 0} {
    ...
}
</pre>

       This is wrong:<p>
 
<pre>
if {$mylist eq ""} {
    ...
}
</pre>

  <li> Use <b>list</b> and <b>lappend</b> to build lists from
       arbitrary data, rather than using string handling routines.<p>

       The string representation of a Tcl list is a
       whitespace-delimited list of tokens.  It's perfectly all right
       to use this fact to type structured data directly into your
       program as list literals; for example, the following is a
       common idiom for initializing an array variable:<p>

       <pre>
array set myarray {
    first   John
    last    Doe
    phone   555-1234
}
</pre>

       When arbitrary data is involved (i.e., variables), relying on
       this is a source of errors.  In the following, list <i>a</i> is
       a two-element list, but list <i>b</i> is a three-element list:<p>

<pre>
set name1 "Joe"
set name2 "John Paul"

set a "name $name1"
set b "name $name2"
</pre>

       If <b>list</b> is used, both lists will have two elements, as
       desired.<p>

<pre>
set name1 "Joe"
set name2 "John Paul"

set a [list name $name1]
set b [list name $name2]
</pre>

</ul>

<section code.callbacks "Callbacks">

Tcl/Tk modules frequently define callback commands which are passed
to other modules to be called at a later time, usually when some
anticipated event occurs.  Three flavors of callback are typically
used:<p>

<ul>
  <li> Script callbacks
  <li> Script callbacks with symbol substitution
  <li> Command prefix callbacks
</ul><p>

Tcl's <b>after</b> command, which is used to define timeout and idle
state callbacks, registers script callbacks.  The callback can be a
Tcl script of any size, from one command to many; <b>after</b> places
no restrictions on it.  (Note: it's usually preferable to
define a <xref timeout(n)> object rather than use a bare
<b>after</b> handler.)<p>

Tk's <b>bind</b> command, which is used to define bindings for
keyboard and mouse events, registers script callbacks with symbol
substitution.  The callback can be a Tcl script of any size, and
event-specific "%" symbols, if present, will be replaced with details
of the event.  On a mouse event, for example, <b>%x</b> and <b>%y</b> will be
replaced with the pixel coordinates of the event.<p>

Other Tk callbacks, such as the <b>scrollbar</b> widget's
<b>-command</b> callback, expect a "command prefix": a partial command
to which the scrollbar will <b>lappend</b> one or more additional arguments
before the command is called.<p>

Whatever the object defining the callback allows, however, the client
should always register a callback which consists of a single command
or command prefix.  The command will usually be a
procedure, method, or typemethod defined just for the purpose, along with
any leading arguments required by the client.<p>

<section code.callbacks.procs "Procedure Callbacks">

If the callback command is a normal command or procedure, possibly with leading
arguments provided by the client, the command should be created using
<b>list</b>:<p>

<pre>
scrollbar .yscroll \
    -orient vertical \
    -command [list .text yview]
</pre>

With the exception of Tk widget commands, the callback command should
almost always be fully qualified.<p>

In a Snit type or widget definition, where the callback procedure is
defined in the body of the type, use <b>myproc</b> instead of list:<p>

<pre>
myobject configure \
    -command [myproc MyCallbackProc arg arg arg...]
</pre>

The <b>myproc</b> command builds the command as a list in the same way
that <b>list</b> does, but also fully-qualifies the procedure's name
automatically.<p>

<section code.callbacks.events "Event Bindings">

In a Tk event binding, any substitutions should be written as
arguments to the command:<p>

<pre>
proc ButtonPress {x y} {
    # Do something
}

# Call ButtonPress when they click on the thingy
bind .thingy <lb>1<rb> [list ButtonPress %x %y]
</pre>

Tk event bindings are allowed to return the <b>break</b> return code;
this tells Tk that no further bindings should be called for the given
event.  The event handler should do this by explicitly returning
the <b>break</b> code, rather than by including "break" in the
callback string.  For example, the following is correct:<p>

<pre>
proc ButtonPress {x y} {
    # Do something

    # Process no further bindings for this button press
    return -code break
}

# Call ButtonPress when they click on the thingy
bind .thingy <lb>1<rb> [list ButtonPress %x %y]
</pre>

Alternatively, the following can be used.<p>

<pre>
bind .thingy <lb>1<rb> {ButtonPress %x %y; break}
</pre>

The following doesn't work at all; <b>break</b> is called when the
callback is defined, not when the button is pressed:<p>

<pre>
bind .thingy <lb>1<rb> [list ButtonPress %x %y; break]
</pre>

<section code.callbacks.methods "Method Callbacks">

Snit instance methods can be used as callbacks.  There are two cases.
In the first, the creator of the Snit object is wiring it up to
some other object.  In this case, the callback command can be created
with <b>list</b>, just as shown in <xref code.callbacks.procs><p>

In the second case, it is the object itself which is passing one of
its own methods to another another object as a callback command.
This usually occurs in the object's constructor.  Here, the
<b>mymethod</b> command should be used to build the callback.
Suppose, for example, the object is creating a Tk <b>button</b>
widget, and wants one of its methods to be called when the button
is pushed:<p>

<pre>
snit::type myobject {
    constructor {} {
        ...
        button .a \
            -text "A"                          \
            -command [mymethod PushHandler .a]

        button .b \
            -text "B"                          \
            -command [mymethod PushHandler .b]
    }

    method PushHandler {btn} {
        if {$btn eq ".a"} {
            ...
        } else {
            ...
        }
    }
}
</pre>

The <b>mymethod</b> command returns a command which will call
the method safely; like <b>list</b>, it allows additional leading
arguments to be included in the callback.<p>

Similarly, use <b>mytypemethod</b> to create callback commands which
call one of a Snit type's typemethods.<p>

<section code.callbacks.calling "Calling Callbacks">

Callbacks should almost always be called in the global scope; any
other choice has too many opportunities for unpleasant surprises.
If the callback command takes no additional arguments, it may be
called like this:<p>

<pre>
uplevel #0 $callback
</pre>

It is frequently the case that the callback might not be defined, as
when it's registered using an object option.  In this case, the code
is:<p>

<pre>
if {$callback ne ""} {
    uplevel #0 $callback
}
</pre>

If the callback takes additional arguments, the code is a little longer:<p>

<pre>
# Call callback with two additional args, a and b
if {$callback ne ""} {
    set cmd $callback
    lappend cmd $a $b
    uplevel #0 $cmd
}
</pre>

Finally, note that the <xref marsutil(n) callwith> command does all this
in one line; the following example is equivalent to its predecessor.<p>

<pre>
callwith $callback $a $b
</pre>

Of course, <xref marsutil(n) callwith> can also be used for callbacks
which take no additional arguments.<p>

Alternatively, if the command prefix might consist of multiple tokens,
"{*}" notation can be used:<p>

<pre>
if {$callback ne ""} {
    {*}$callback $a $b
}
</pre>

This presumes that the callback command is fully-qualified, as it should
be.<p>

<section file "File Layout">

This section contains standard regarding to the placement, contents,
and layout of various kinds of Tcl code files.<p>

<section file.scripts "Executable Scripts">

<ul>
  <li> Executable scripts should be placed in the project
       <code>bin/</code> or <b>tools/bin</b> directory, and
       should be documented with a man page in <b>docs/man1/</b>.<p>

  <li> The names of executable Tcl script files should omit the ".tcl"
       suffix.<p>

  <li> Executable Tcl script files should begin with the following
       lines, where "wish" (or another interpreter) can be substituted
       for "tclsh" as required:<p>

<pre>
#!/bin/sh
# -*-tcl-*-
# The next line restarts using tclsh \
exec tclsh8.5 "$0" "$@"
</pre>

       The "#-*-tcl-*-" line allows Emacs to recognize that the file
       is a Tcl file.<p>
</ul><p>

<section file.scripts.classic "Classic Script Layout">

In the classic layout, the script will usually have the following
skeleton.<p>

<pre>
#!/bin/sh
# -*-tcl-*-
# The next line restarts using tclsh \
exec tclsh8.5 "$0" "$@"

#-----------------------------------------------------------------------
# FILE: sample
#
# sample(1) Script.  A skeleton for executable scripts.
#
# PROJECT:
#   Name of the project to which this package belongs
#
# AUTHOR:
#    Will Duquette
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Required Packages

package require marsutil

namespace import marsutil::*

#-----------------------------------------------------------------------
# Variables

# Declare and initialize global variables here

#-----------------------------------------------------------------------
# Main Line Code

# main argv
#
# argv - The script's command-line arguments
#
# This is the script's main routine.

proc main {argv} {
    ...
}

# Other main-line routines follow

#-----------------------------------------------------------------------
# Utility Commands

# small utility commands needed by the main-line code are defined
# here.

#-----------------------------------------------------------------------
# Invocation

main $argv
</pre>

<section file.scripts.app "Application Ensemble Layout">

In this layout, the script's code is grouped into an application
ensemble, conventionally called <b>app</b>.  Application ensembles are
easily created using Snit.  The skeleton is as follows:<p>

<pre>
#!/bin/sh
# -*-tcl-*-
# The next line restarts using tclsh \
exec tclsh8.5 "$0" "$@"

#-----------------------------------------------------------------------
# FILE: sample
#
# sample(1) Script.  A skeleton for executable scripts.
#
# PROJECT:
#   Name of the project to which this package belongs
#
# AUTHOR:
#    Will Duquette
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Required Packages

package require snit
...

#-----------------------------------------------------------------------
# app
#
# Additional description of the type.

snit::type app {
    pragma -hasinstances no

    #--------------------------------------------------------------------
    # Type Variables

    # Define and initialize any type variables here.

    #--------------------------------------------------------------------
    # Main

    # main argv
    #
    # argv - The script's command-line arguments
    #
    # This is the script's main routine.

    typemethod main {arg} {
        ...
    }

    # Other main-line routines go here

    #-------------------------------------------------------------------
    # Utility Type Methods

    # Utility type methods and/or procs go here
}

#-----------------------------------------------------------------------
# Invocation

app main $argv
</pre>

<section file.package "Packages">

Tcl libraries are called "packages".  Packages are defined in
subdirectories of the project <code>lib/</code> directory; each
subdirectory contains one package. The directory name is the same as the
package name; thus, the <xref marsutil(n)> package resides in the
<code>mars/lib/marsutil</code> directory.<p>

Mars defines two kinds of packages: library packages and application
packages.  A library package is a traditional library; an application
package is an application's main body of code packaged as a Tcl
package, to be loaded by the <xref mars(1)> loader script.
Application package names all begin with "app_".<p>

A library package's API is documented by one or more
man pages in <code>mars/docs/mann</code>, one man page for the package
itself and one for each of its submodules (e.g., <xref marsutil(n)>,
<xref mat(n)>).  An application is documented for the user
as a single man page in <code>mars/docs/man1</code>, e.g.,
<xref mars_gram(1)>.<p>

Every package has a package index file (<xref file.package.index>),
a package loader file (<xref file.package.loader>), and one or more
module files (<xref file.mod>); all of these files reside in the
package's subdirectory.<p>

Every package has a version number, e.g., "1.0".  The version number
if extremely important for packages released "into the wild"; for
packages used only in a single software system that is maintained in a
CM repository, as Mars is, the version can usually be set to "1.0" and
ignored.<p>

<section file.package.index "Package Index Files">

The package index file is always called <code>pkgIndex.tcl</code>;
it notifies the Tcl interpreter that the package exists.  Tcl provides
a tool, the <b>pkg_mkIndex</b> command, which will build the
<code>pkgIndex.tcl</code> file automatically; it should <b>not</b> be
used.  Instead, the following skeleton should be used.<p>

<pre>
#-------------------------------------------------------------------------
# TITLE:
#    pkgIndex.tcl
#
# AUTHOR:
#    William H. Duquette
#
# DESCRIPTION:
#    Mars: mypackage(n) package index file

package ifneeded mypackage 1.0 [list source [file join $dir mypackage.tcl]]
</pre>

Replace "mypackage" with the actual package name throughout.<p>

<section file.package.loader "Package Loader Files">

The package loader file always has the same name as the package, e.g.,
"mypackage.tcl".  It has the following responsibilities:<p>

<ul>
  <li> It loads any other packages used by this package.<p>

  <li> It notifies Tcl that this package has been loaded.<p>

  <li> For library packages:<p>

       <ul>
         <li> It defines the package namespace, which
              has the same name as the package.  All library package
              code and variables lives in the package namespace.<p>

         <li> It defines the package's "library" variable, which
              contains the absolute path to the package's directory.
              This is useful of the package needs to access data files
              (such as icon files).<p>

         <li> It imports commands from other packages into the package
              namespace, if desired.<p>
       </ul><p>

  <li> It loads each of the package's submodules, each of which has
       its own file.<p>
</ul>

The following is a typical skeleton for a package loader file.<p>

<pre>
#-----------------------------------------------------------------------
# FILE: mypackage.tcl
#
# Package loader.  This file provides the package, requires all
# other packages upon which this package depends, and sources in
# all of the package's modules.
#
# PACKAGE:
#   mypackage(n) -- One-line description of package
#
# PROJECT:
#   Mars Simulation Infrastructure Library
#
# AUTHOR:
#    Will Duquette
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# External Package Dependencies

package require snit
package require sqlite3
package require tdom

#-----------------------------------------------------------------------
# Internal Package Dependencies

package require marsutil

# An application package's loader file would import names here.

#-----------------------------------------------------------------------
# Package Definition

package provide mypackage 1.0

#-----------------------------------------------------------------------
# Namespace definition

namespace eval ::mypackage:: {
    variable library [file dirname [info script]]

    # A library package imports names here
    namespace import ::marsutil::* 
}

#-----------------------------------------------------------------------
# Load mypackage(n) submodules

source [file join $::mypackage::library this.tcl]
source [file join $::mypackage::library that.tcl]
source [file join $::mypackage::library theother.tcl]
</pre>

<section file.mod "Code Modules">

This section describes the content and layout of Tcl code modules,
which are assumed to belong to either a library or an application
package.  The differences between library and application modules are
described in <xref file.mod.libvsapp>; then,
different module patterns within these two broad categories are
discussed in <xref file.mod.classic> and following.<p>

<section file.mod.libvsapp "Library vs. Application Modules">

The main distinction between library and application modules is that
library modules live in the library package's namespace, whereas
application modules are allowed to live in the global namespace
(though they may define their own).<p>

The following is a skeleton for a simple library module:<p>

<pre>
#-----------------------------------------------------------------------
# FILE: this.tcl
#
# One-line description of module
#
# PACKAGE:
#   mypackage(n) -- One-line description of package
#
# PROJECT:
#   Mars Simulation Infrastructure Library
#
# AUTHOR:
#   Will Duquette
#
#-----------------------------------------------------------------------

namespace eval ::mypackage:: {
    namespace export \
        fred \
        george
}

#-----------------------------------------------------------------------
# Public Commands

# fred
# ...

proc ::mypackage::fred {} {
    ...
}

# george
# ...

proc ::mypackage::george {} {
    ...
}

...
</pre>

It begins with code that exports all public commands defined in the
package from the package namespace; this is followed by the file's
content.  Command names to be exported should be listed one per line in
alphabetical order, as shown.<p>

The <b>namespace export</b> command allows wildcards to be used when
specifying the commands to export; for example, the following command
will export all commands whose names begin with a lowercase letter
(and are thus public by our conventions):

<pre>
# Don't Do This!
namespace export [a-z]*
</pre>

<b>Don't do this!</b>  It saves typing, but it leads to problems: any
public commands imported from other packages will then be exported by
this package!  As it is generally an error to import two commands with
the same name into a single namespace (or the same command twice),
this practice can yield annoying integration bugs at inconvenient
times.<p>

Generally speaking, application modules will look the
same but won't define a namespace or export any names.<p>

Note that there is no need to define the package (<b>package
provide</b>) or to load packages needed by this one (<b>package
require</b>) or import names into the package namespace
(<b>namespace import</b>), because the package loader file should
already have done this (<xref file.package.loader>).<p>

The nature of the file's content depends on the module pattern used;
see <xref file.mod.classic> and following.<p>

<section file.mod.classic  "Classic Modules">

This section describes the layout and content of a classic Tcl library
module (of which there are relatively few in Mars) which uses a
namespace to protect itself from interference with other modules.
If the module is a library module, the namespace will be the package
namespace.  If the module is an application module, the namespace
will be specific to the module--or the module might define its
commands and variables in the global namespace.<p>

A classic module contains the following things:<p>

<ul>
  <li> A <b>namespace eval</b> section which:<p>
       <ul>
         <li> Exports public command names using <b>namespace export</b>.
         <li> Declares and initializes module variables using <b>variable</b>.
       </ul>
  <li> Public procs, defined in the module's namespace and exported above.<p>

  <li> Private procs, defined in the module's namespace.<p>
</ul>

A typical skeleton looks like this:<p>

<pre>
#-----------------------------------------------------------------------
# FILE: classic.tcl
#
# Classic Stuff
#
# PACKAGE:
#   mypackage(n) -- One-line description of package
#
# PROJECT:
#   Mars Simulation Infrastructure Library
#
# AUTHOR:
#   Will Duquette
#
#-----------------------------------------------------------------------

namespace eval ::mypackage:: {
    namespace export \
        fred \
        george
}

#-----------------------------------------------------------------------
# Public Commands

# fred
#
# ....

proc ::mypackage::fred {} {
    ...
}

# george
#
# ...

proc ::mypackage::george {} {
    ...
}

...

#-----------------------------------------------------------------------
# Private Commands

# ComputeGadgetFrequency
#
# ...

proc ::mypackage ComputeGadgetFrequency {} {
    ...
}
</pre>

The file may be divided into sections as best makes sense for the
content.<p>

<section file.mod.ensemble "Ensemble Modules">

An <i>ensemble module</i> defines a single public ensemble command
that serves as the sole entry point to the module's functionality.
The ensemble is implemented as a Snit type with no instances; the
ensemble command's subcommands are typemethods of the type.  All of
the module's code is defined within the type definition.<p>

An ensemble module will contain the following things:<p>

<ul>
  <li> The Snit type, whose name should be same as that of the
       module.  If the module is "mymodule.tcl", the type name should
       be "mymodule".<p>

  <li> If the type requires significant initialization, it should
       define an <b>init</b> typemethod so that the application can
       choose when to initialize it.<p>

  <li> Library modules which require significant initialization
       controlled by the application should generally be written as
       object modules (<xref file.mod.object>) rather than as
       ensemble modules.<p>

  <li> For library modules:<p>

       <ul>
         <li> The type should be defined in the package namespace.<p>

         <li> The module should begin with a <b>namespace eval</b>
              block which exports the ensemble's name from the package
              namespace.<p>
       </ul>

       Note that every type defines its own namespace; hence,
       application modules which use this pattern have no need to
       define an module-specific namespace beyond that provided by the
       type.<p>

  <li> If necessary, the module can import names from other packages
       into its own namespace.<p>
</ul>

The skeleton for ensemble modules should look like this; as always,
the type definition can be divided into sections as best documents
its content.<p>

See also the
<link http://tcllib.sourceforge.net/doc/snitfaq.html "Snit FAQ">
for best practices for Snit types.<p>

<pre>
#-----------------------------------------------------------------------
# FILE: mymodule.tcl
#
# My Ensemble Module
#
# PACKAGE:
#   mypackage(n) -- One-line description of package
#
# PROJECT:
#   Mars Simulation Infrastructure Library
#
# AUTHOR:
#   Will Duquette
#
#-----------------------------------------------------------------------

# Leave this out for application modules.
namespace eval ::mypackage:: {
    namespace export \
        mymodule
}

#-----------------------------------------------------------------------
# mymodule ensemble
#
# Longer overview of mymodule

snit::type mymodule {
    # Make it an ensemble
    pragma -hasinstances no

    #-------------------------------------------------------------------
    # Type Constructor

    typeconstructor {
        namespace import myotherpackage::* 
    }

    #-------------------------------------------------------------------
    # Type Variables

    ...

    #-------------------------------------------------------------------
    # Initialization

    # init
    #
    # Initializes the module

    typemethod init {} {
        ....
    }

    #-------------------------------------------------------------------
    # Public Type Methods

    ...
}
</pre>


<section file.mod.object "Object Modules">

An <i>object module</i> defines a single Snit type or widget, usually
with no extra type methods.  If type methods are required for a
non-widget type, then the manager/object module pattern should be used
instead (<xref file.mod.manager>).  All of the module's code is defined
within the type definition.<p>

An object module will contain the following things:<p>

<ul>
  <li> The Snit type or widget, whose name should be same as that of the
       module.  If the module is "myobject.tcl", the type name should
       be "myobject".<p>

  <li> For library modules:<p>

       <ul>
         <li> The type or widget should be defined in the package namespace.<p>

         <li> The module should begin with a <b>namespace eval</b>
              block which exports the ensemble's name from the package
              namespace.<p>
       </ul>

       Note that every type defines its own namespace; hence,
       application modules which use this pattern have no need to
       define an module-specific namespace beyond that provided by the
       type.<p>

  <li> If necessary, the module can import names from other packages
       into its own namespace.<p>
</ul>

The skeleton for object modules should look like this; as always,
the type definition can be divided into sections as best documents
its content.<p>

See also the
<link http://tcllib.sourceforge.net/doc/snitfaq.html "Snit FAQ">
for best practices for Snit types and widgets.<p>


<pre>
#-----------------------------------------------------------------------
# FILE: myobject.tcl
#
# My Object Type
#
# PACKAGE:
#   mypackage(n) -- One-line description of package
#
# PROJECT:
#   Mars Simulation Infrastructure Library
#
# AUTHOR:
#   Will Duquette
#
#-----------------------------------------------------------------------

# Leave this out for application modules.
namespace eval ::mypackage:: {
    namespace export \
        myobject
}

#-----------------------------------------------------------------------
# myobject type

snit::type myobject {
    #-------------------------------------------------------------------
    # Type Constructor

    typeconstructor {
        namespace import myotherpackage::* 
    }

    #-------------------------------------------------------------------
    # Components

    ...

    #-------------------------------------------------------------------
    # Options

    ...

    #-------------------------------------------------------------------
    # Instance Variables

    ...

    #-------------------------------------------------------------------
    # Constructor/Destructor

    # constructor
    #
    # ...

    constructor {args} {
        ....
    }

    #-------------------------------------------------------------------
    # Public Type Methods

    ...
}
</pre>

<section file.mod.manager "Manager/Object Modules">

Given a collection of objects of a particular type, it's sometimes
useful to provide a manager interface that operates on the entire
collection or which can locate particular objects given relevant inputs.<p>

Snit supports this pattern by allowing a type to have both type
methods (subcommands of the type command) and instance methods
(subcommands of the object instances).  The management activities can
be implemented in terms of type methods and type variables, both of
which the instances can access.<p>

<b>This mechanism should not be used for non-GUI object types,
as it leads to confusing errors!</b>  One of the features of Snit is that
instances are created by the type's <b>create</b> type method--which can be
omitted. This means that if the type is passed a type method name which is
misspelled, the type assumes it to be an instance name and quietly creates
an instance with that name. The call appears to succeed, but
doesn't do anything like what was wanted.<p>

Note that Snit widgets do not have this problem.  Tk window names must
begin with a ".", and subcommand names simply don't.  Thus, it's
unlikely that a mispelled subcommand would cause a new window to be
created.<p>

For non-GUI object types, though, the manager/object pattern should be
implemented using two
types: an ensemble, as shown in <xref file.mod.ensemble>, followed
by an object type or widget, as shown in <xref file.mod.object>.
The typical skeleton for this pattern is simply a combination of the 
ensemble and object module skeletons.<p>

When this pattern is used, the ensemble will usually have a typemethod
explicitly defined for creating objects of the object or widget type.<p>

</document>







